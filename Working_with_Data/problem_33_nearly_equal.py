# Write a function nearly_equal to test whether two strings are nearly equal. Two strings a and b are nearly equal when a can be generated by a single mutation on b.

ret = []
w = []
b = []
a = []
s = []
ml = []
l = []
t = ''
clen = 0


def mutate(d):
   clen = len(d)
# creating a list of alphabets from a to z
   alp=map(chr,range(97,123))
   for i in alp:
      a.append(i)
   s=[]
   for i in range(clen):
      s.append(d[i])
# inserting values
   for i in a:
      for j in range(clen):
         if j < (clen):
            s.insert(j,i)
            ml.append(s)
            #print(s)
            s = []
            for x in range(clen):
               s.append(d[x])
         if j == (clen -1):
            s.append(i)
            ml.append(s)
            s = []
            for x in range(clen):
               s.append(d[x])      
#removing any one value at a time
   for p in range(clen):
      s = []
      w = []
      for r in range(clen):
         s.append(d[r])
         w.append(d[r])
      s.remove(w[p])
      ml.append(s)
# replacing a value with any value in a to z
   s= []
   for q in range(clen):
      s.append(d[q])      
   for e in a:
      for f in range(clen):
         s[f] = e
         #print(s)
         ml.append(s)
         s = []
         for o in range(clen):
            s.append(d[o]) 

# swapping any two concecutive characters.

   for t in range(clen):
      if(t < (clen -1)):
         temp = s[t]
         s[t] = s[t+1]
         s[t+1] = temp
         ml.append(s)
         #print(s)
         s = []
         for t1 in range(clen):
            s.append(d[t1])

# converting list into string. 
   for val in ml:
      ret.append(("").join(val)) 
   return ret



def nearly_equal(v1,v2):
   if len(v1)>len(v2):
      lvmax = v1
      lvmin = v2
   else:
      lvmax = v2
      lvmin = v1
   if (lvmin in mutate(lvmax)):
      print ("True")
   else:
      print ("False")

nearly_equal('python','perl')
nearly_equal('perl', 'pearl')
nearly_equal('python', 'jython')
nearly_equal('man', 'woman')
